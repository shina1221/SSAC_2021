# 깊이우선탐색 & 너비우선탐색

#깊이우선탐색(DFS)
-Depth First Search의 약자로 넓이 우선탐색 의미
하나의 경우의 수에 대해 모든 경우의 수를 조사하고 다음 경우의 수를 조사하면서 해를 찾는 과정

    #구조
              (1)A
       |       |       |
    (2)B      (8)C    (11)D   
    |  |       |       |   \
  (3)E (5)F   (9)G    (12)H (14)I
  |    |  |    |       |   \
(4)J (6)K (7)L (10)답 (13)N (15)O 

# 스택의 깊이우선 탐색 활용
 
                               (검사한 요소 제외)
                            (아래 남아있는 요소 추가)
              검사중인 요소의    한쪽방향에서만  
     검사중   밑에 있는 요소들  접근가능한 스택 
        A         [B,C,D]      >    [B,C,D]
       
        B         [C,D]        >    [E,F,C,D]

        E         [J]          >    [J,F,C,D]

        J         []           >    [F,C,D]

        F         [C,D]        >    [K,L,C,D]

        K         []           >    [L,C,D]

        L         []           >    [C,D]

        C         [G]          >    [G,D]

        G         [정답]       >    [D]


# 깊이우선탐색(DFS) 구현

- ex)미로찾기

    좌표 0 1 2 3 4 5 y
    0  0 0 0 0 0 0
    1  1 0 1 1 1 0
    2  0 0 1 0 1 0
    3  0 1 1 0 0 0
    4  0 0 1 1 1 1 
    5  1 0 0 0 0 0 >도착
    x
                              
               접근가능한    
     검사중      좌표들       
      [0,0]      [[0,1]]     <접근가능 좌표의 가장 마지막을 빼옴
       
      [0,1]   [[1,1],[0,2]]      

      [0,2]   [[1,1],[0,3]]  

      [0,3]   [[1,1],[0,4]]  

      [0,4]   [[1,1],[0,5]]  

      [0,5]   [[1,1],[1,5]]  

      [1,5]   [[1,1],[2,5]]  

      [2,5]   [[1,1],[3,5]]  

      [3,5]   [[1,1],[3,4]]  

      [3,4]   [[1,1],[3,3]]  

      [3,3]   [[1,1],[2,3]]  
      
      [2,3]   [[1,1]]  

      [1,1]   [[2,1]]

      [2,1]   [[2,0]]

      [2,0]   [[3,0]]

      [3,0]   [[4,0]] 

      [4,0]   [[4,1]]           

      [4,1]   [[5,1]]           

      [5,1]   [[5,2]]                 

      [5,2]   [[5,3]]           

      [5,3]   [[5,4]] 

      [5,4]   [[5,5]]  
      
      [5,5]   []             #True 반환 뒤 종료

#깊이우선탐색(DFS) 예시코드

while len(stack)>0:                  #스택에 데이터가 있다면                             
    if now == dest(목적지):          #정답여부 검사      #스택의 가장 마지막 데이터 추출
        return True: #도착           #정답여부 검사
    x=now[1]                         #정답여부 검사      #x는 오른쪽과 왼쪽방향을 나타냄
    y=now[0]                         #정답여부 검사      #y는 위 아래 방향을 나타냄
    if x -1 > -1:                    #왼쪽으로 이동할 수 있다면    #x값은 왼쪽방향으로 갔을 때 인덱스를 벗어나지 않을때
        if maps[y][x-1]==0:          #왼쪽으로 이동할 수 있다면    #갈수 있는 길이라면
            stack.append([y,x-1])    #왼쪽으로 이동할 수 있다면    #기존의 값을 스택에 담고
            maps[y][x-1]=2           #왼쪽으로 이동할 수 있다면  #갈 수 있는 길이라면 스택에 추가하고 방문여부 2로 표시 이렇게 새로 갱신하지 않으면 무한루프에 빠짐
        if x + 1 < hori:             #오른쪽으로 이동할 수 있다면
            if maps[y][x+1]==1:      #오른쪽으로 이동할 수 있다면
                stack.append([y,x+1])#오른쪽으로 이동할 수 있다면
                maps[y][x+1]=2       #오른쪽으로 이동할 수 있다면  
        if y - 1 > -1:               #위로 이동할 수 있다면
            if maps[y-1][x]==1:      #위로 이동할 수 있다면
                stack.append([y-1,x])#위로 이동할 수 있다면
                maps[y-1][x]=2       #위로 이동할 수 있다면
        if y + 1 < verti:            #아래로 이동할 수 있다면
            if maps[y+1][x]==1:      #아래로 이동할 수 있다면
                stack.append([y+1,x])#아래로 이동할 수 있다면
                maps[y+1][x]=2       #아래로 이동할 수 있다면 
    return False                     #스택에 데이터가 없으면 False


#너비우선탐색(BFS)

    #구조
              (1)A
       |       |       |
    (2)B      (3)C    (4)D   
    |  |       |       |   \
  (5)E (6)F   (7)G    (8)H (9)I
  |    |  |    |       |   \
(10)J (11)K (12)L (13)답 (14)N (15)O 

# 큐의 너비우선 탐색 활용
 
                               (검사한 요소 제외)
                            (아래 남아있는 요소 추가)
              검사중인 요소의      양쪽방향에서 
     검사중   밑에 있는 요소들     접근가능한 큐 
        A         [B,C,D]      >    [B,C,D]
       
        B         [C,D]        >    [C,D,E,F]

        C         [D,E,F]      >    [D,E,F]

        D         [E,F]           >    [F,C,D]

        F         [C,D]        >    [K,L,C,D]

        K         []           >    [L,C,D]

        L         []           >    [C,D]

        C         [G]          >    [G,D]

        G         [정답]       >    [D]

# 너비우선탐색(BFS) 구현

- ex)최단경로찾기
 1 - 2 - 3 - 4
 | \   / | \ |
 5 - 6 - 7 - 8
 |     /   /   
 9 - 10  11  12 도착 
 
 #대강 이런느낌의 문제  

1번 섬에서부터 12번 섬까지 가는 최단 경로는 얼마인가?


#너비우선탐색(BFS) 예시코드
                                                
while len(queue)>0:                              #큐에 데이터가 있다면
    #아래의 queue는 같은 거리에 있는 큐 데이터 갯수  
    count = len(queue)                           #같은 거리에 있는 큐 개수 만큼 검사  
    for time in range(count):                    #같은 거리에 있는 큐 개수 만큼 검사
    now = queue.pop(0)                           #같은 거리에 있는 큐 개수 만큼 검사
    if now == dest(목적지):                      #정답이 존재하면 값 반환
        return answer                            #정답이 존재하면 값 반환
    for i in data:                               #연결된 포인트 완전 탐색
        if i[0]==now and visited[i[1]-1]==False: #연결된 포인트 완전 탐색 #방문하지 않은 연결된 길이라면 큐에 추가하고 방문 표시
        queue.append(i[1])                       #연결된 포인트 완전 탐색
        visited[i[1]-1]=True                     #연결된 포인트 완전 탐색  
    elif i[1]==now and visited[i[0]-1]==False:   #연결된 포인트 완전 탐색
        queue.append(i[0])                       #연결된 포인트 완전 탐색 
        visited[i[0]-1]=True                     #연결된 포인트 완전 탐색
    answer+=1                                    #거리를 1 더 벌림
return answer     
