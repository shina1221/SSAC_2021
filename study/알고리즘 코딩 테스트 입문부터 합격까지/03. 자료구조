"""
배열 array
삽입/삭제: O(N)
탐색:O(1)
c++에서는 사이즈 변경불가
python은 리스트 사용
#python
arr = [10,11,12,13]
arr[2] = 12


arr [0][1][2][3]
    10 11 12 13
    
    arr[2]
    arr+2*4byte = 메모리 주소값
    따라서 시간복잡도는 O(1)이됨 이를 임의 접근(random access)이라고 함

    배열은 메모리상에 연속적으로 공간이 할당되어 임의접근이 가능하고 따라서 탐색속도가 빠름 

# 삽입시
  배열 중간에 값을 추가할 경우
  뒤에 올 배열들을 모두 한칸씩 뒤로 미뤄 새로운 공간을 만들고 삽입함
  삽입을 할때마다 이와 같은 과정이 반복됨
  따라서 맨 뒤에 추가할 때는 0번 미루게 되고
  맨앞에 추가할 경우 N번 미루게 됨
  시간복잡도는 최악을 상정하므로 0(N)이 됨   

삽입삭제를 많이 하지 않을 때 탐색할 때는 배열이 유리
"""

"""
vector 벡터
삽입/삭제: O(N)
탐색: O(1)
동적배열 (size 변경가능)
#python 리스트 튜플 사용가능
v = []
v.append((123, 456))
v.append((789, 987))
print('size', len(v)) => 요소는 2가 됨
"""

"""
연결 리스트 (Linked List)
삽입/삭제 : O(1)
탐색:O(N)
#배열과 달리 삽입삭제가 빠르고 임의 접근이 불가능하기 때문에 탐색이 느림
  0         1              2 
[][]----[][]-------[][] #size3 연결리스트
5       0          99     
각 노드가 메모리상에 아무데나 있음(연속적으로 존재하지 않음)
각 노드는 노드가 저장하려는 값을 가지고 있고 다음 노드가 어딨는지 메모리 주소를 저장하는 부분을 포함
다음 노드는 어딨는지 이전노드만 앎 따라서 O(N)

#삽입
연결리스트에서는 새로운 값을 가지고 있는 노드를 생성한 뒤
다음에 올 메모리 주소값을 현재 삽입하고자 하는 노드에 저장
이후 선행되는 노드에 현재 추가되는 노드의 주소를 저장

"""