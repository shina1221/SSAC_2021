"""
그래프

트리는 대체적으로 부모 자식 관계 방향이 있는 방향그래프를 일컬음
방향성이 없는 것도 존재

인접행렬(무방향) 노드가 N개면 무조건 N^2개만큼 메모리를 쓰게 됨
                 시간과 공간은 서로 트레이드오프되기에 시간측면에서 더 유리
                 //임의 접근을 이용해 접근 가능성 빠르게 확인가능 
인접리스트(방향존재) 간선이 적으면 적을 수록 메모리를 적게 먹음
                     대신 시간이 더 걸림
                     //특정 값이 존재하는지 보기 위해선 특정값이 나올 때까지 파악해야함.


정점이 N개이고 간선이 N^2개일 때는 인접행렬 사용
       N개            2N개         인접리스트 사용
"""

"""
DFS
깊이우선탐색
스택이나 재귀를 사용해서 구현
            0
      1            7
   2    5      8       9
3    4  6           10 11 12 

"""
adj = [[0] *13 for _ in range(13)]
adj[0][1] = adj[0][7] = 1
adj[1][2] = adj[1][5] = 1

def dfs(now):
    for nxt in range(13):
        if adj[now][nxt]:
            dfs(nxt)

dfs(0)

"""
BFS
너비우선탐색
큐를 사용해서 구현

"""
adj = [[0] *13 for _ in range(13)]
adj[0][1] = adj[0][2] = 1
adj[1][3] = adj[1][4] = 1

from collections import deque

def bfs():
    dq = deque()
    dq.append(0) #0번으로 시작해야 하므로
    while dq:
        now = dq.popleft()
        for nxt in range(13):
            if adj[now][nxt]:
                dq.append(nxt)

bfs()

"""
DFS와 BFS

공통점
모든 경우의 수를 찾아봄
그렇기 때문에 느리다

차이점
탐색 순서가 다름

BFS는 자신이 갈 수 있는 거리를 대상으로 모든 노드를 탐색할 수 있어 
최단거리를 구하는 문제에 적합

인접행렬 vs 인접리스트
인접행렬:O(V^2)
인접리스트:O(V+E) // O(max(V,E))

"""