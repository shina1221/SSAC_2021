#매개변수 선택
"""
최적화 문제를 결정문제롤 바꿔서 이진탐색으로 푸는 방법

최적화 문제
-문제 상황을 만족하는 변수의 최솟값, 최댓값을 구하는 문제
결정문제
-yes or no 문제

#예제
수강생들의 외모값과 커플/솔로 여부가 주어진다
커플들은 솔로들보다 외모값이 높다
외모값이 최소 몇 이상일 때부터 커플인가

#파라메트릭 서치
매개변수 parameter가 주어지면 true 혹은 false가 결정되어야 한다
가능한 해의 영역이 연속적이어야 한다
범위를 반씩 줄어가면서 가운데 값이 true 인지 false 인지 구한다.
이진탐색과 똑같은 원리
다만 이진탐색은 정수의 배열에서 특정값을 찾는것이고
파라메트릭 서치는 경계선을 찾는다고 보면 됨
"""

#백준 2512. 예산
"""
국가의 역할 중 하나는 여러 지방의 예산요청을 심사하여 국가의 예산을 분배하는 것이다. 국가예산의 총액은 미리 정해져 있어서 모든 예산요청을 배정해 주기는 어려울 수도 있다. 그래서 정해진 총액 이하에서 가능한 한 최대의 총 예산을 다음과 같은 방법으로 배정한다.

모든 요청이 배정될 수 있는 경우에는 요청한 금액을 그대로 배정한다.
모든 요청이 배정될 수 없는 경우에는 특정한 정수 상한액을 계산하여 그 이상인 예산요청에는 모두 상한액을 배정한다. 상한액 이하의 예산요청에 대해서는 요청한 금액을 그대로 배정한다. 
예를 들어, 전체 국가예산이 485이고 4개 지방의 예산요청이 각각 120, 110, 140, 150이라고 하자. 이 경우, 상한액을 127로 잡으면, 위의 요청들에 대해서 각각 120, 110, 127, 127을 배정하고 그 합이 484로 가능한 최대가 된다. 

여러 지방의 예산요청과 국가예산의 총액이 주어졌을 때, 위의 조건을 모두 만족하도록 예산을 배정하는 프로그램을 작성하시오.

입력
첫째 줄에는 지방의 수를 의미하는 정수 N이 주어진다. N은 3 이상 10,000 이하이다. 다음 줄에는 각 지방의 예산요청을 표현하는 N개의 정수가 빈칸을 사이에 두고 주어진다. 이 값들은 모두 1 이상 100,000 이하이다. 그 다음 줄에는 총 예산을 나타내는 정수 M이 주어진다. M은 N 이상 1,000,000,000 이하이다. 

출력
첫째 줄에는 배정된 예산들 중 최댓값인 정수를 출력한다. 
"""
import sys
N = int(sys.stdin.readline())
req = list(map(int, sys.stdin.readline().split()))
M = int(sys.stdin.readline())

lo =0
hi =max(req)
mid = (lo+hi)//2 #기준이 되는 수
ans = 0

#풀이
def is_possible(mid):
    return sum(min(r,mid) for r in req) <= M

while lo<=hi:
    print(f'lo: {lo}, mid:{mid}, hi:{hi}, ans:{ans}')
    if is_possible(mid): #기준 총량보다 작거나 같다면
        lo=mid+1 #중앙값의 다음 행부터 서치 
        ans=mid #작거나 같으면에 해당하는 조건이기 때문에 mid값을 답으로 잡아둠
    else: #기준 총령보다 작다면
        hi=mid-1  #중앙값의 바로 아랫수를 최대수로 잡음 즉 최소값에서 중앙값 사이의 범위를 서치
    mid = (lo+hi)//2

print(ans)



#백준 10815 숫자카드
"""
문제
숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 가지고 있는지 아닌지를 구하는 프로그램을 작성하시오.

입력
첫째 줄에 상근이가 가지고 있는 숫자 카드의 개수 N(1 ≤ N ≤ 500,000)이 주어진다. 둘째 줄에는 숫자 카드에 적혀있는 정수가 주어진다. 숫자 카드에 적혀있는 수는 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다. 두 숫자 카드에 같은 수가 적혀있는 경우는 없다.

셋째 줄에는 M(1 ≤ M ≤ 500,000)이 주어진다. 넷째 줄에는 상근이가 가지고 있는 숫자 카드인지 아닌지를 구해야 할 M개의 정수가 주어지며, 이 수는 공백으로 구분되어져 있다. 이 수도 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다

출력
첫째 줄에 입력으로 주어진 M개의 수에 대해서, 각 수가 적힌 숫자 카드를 상근이가 가지고 있으면 1을, 아니면 0을 공백으로 구분해 출력한다.
"""
import sys

#풀이
N = int(sys.stdin.readline())
cards = list(map(int, sys.stdin.readline().split())).sort() 
M = int(sys.stdin.readline())
qry = list(map(int, sys.stdin.readline().split()))
ans=[]

from bisect import bisect_left, bisect_right
for q in qry:
    l=bisect_left(cards,q)
    r=bisect_right(cards,q)
    #if r-1>0: 이런 방법으로 확인하는 방법도 존재
    #print(l,r)
    #if cards[l]==q:
        #ans.append(1 if r-1 > 0 else 0)    
    ans.append(1 if r - l else 0)

#리스트 값을 한줄에 출력하는 방법
print(*ans)
print(' '.join(map(str, ans)))

"""
이진탐색(binary search)정리
탐색 전 반드시 정렬되어 있어야 함
살펴보는 범위를 절반 씩 줄여가며 답을 찾음

정렲 O(NlogN) + 이진탐색O(logN) 결과적으로 O(NlogN)
미리 정렬되어 들어오면 이진탐색만 하면 되므로 O(logN)

parametric search 매개변수 탐색
최적화문제를 결정문제로 바꿔서 이진탐색으로 푸는 방법



"""